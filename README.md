# Project README

## Prerequisites

Ensure you have Docker installed on your machine.

## Building the Docker Image

To build the Docker image for this project, use the following command:

```bash
docker build -t echorus:latest .
```

This command will create a Docker image tagged as `echorus:latest`.

## Running the Docker Container

Once the image is built, you can run the container with the following command:

```bash
docker run -p 8000:8000 echorus
```

This command will start a new container from the `echorus:latest` image.

## Making a request

Once the container is up, you can open [this link](http://127.0.0.1:8000/docs) to see the autogenerated docs for the APIs.

## Questions:
### 1. What has been the most difficult part?
Playing with the API of HackerNews and try different requests and responses

### 2. What part of the system could be improved?
The current system doesn't use cache. Storing the response of top stories can help reduce the API's response time.

### 3. How would you scale it, to be able to handle 1K calls per sec? and to handle 1M?
The bottleneck here is the API calls to the HackerNews endpoints. Hence, we can use more workers for our fastApi server and use more instances of our service can help responding to more users. Also, as mentioned before, adding cache can help a lot. for example we are getting the comments of stories everytime there's a request to the endpoints. Given that for most of the stories the comments don't change, we can cache the comments of stories in a key-value store.
There's another way we can improve our system. We can cache our response to the requests, too.

### 4. How would you automate the testing?
We can use mocking tools to mock the external API with the contents we want and check the validity of our APIs with the provided content.  
We can also use libraries like BeautifulSoup to crawl some pages of HackerNews and check if the results from the API matches the results from crawling the pages.

### 5. How would you implement a continuous development system (pipelines) for this particular case?
1. Select a CI/CD platform. For this example, we can use a basic setup using GitHub Actions, but the general principles apply to other platforms as well.

2. Create a CI/CD Pipeline Configuration: Create Workflow File, Define Workflow Steps. The workflow will include steps to check out the code, build the Docker image, run tests, and optionally deploy the image.

3. Setting Up Secrets
If the pipeline requires access to private resources, such as a Docker registry, set up the necessary secrets (e.g., REGISTRY_USER, REGISTRY_PASS) in the repository's settings.

4. Running Tests
The Docker container should include a script or command (./run_tests.sh) to execute tests. This script should run any unit, integration, or end-to-end tests required to validate the app.

5. Deploying
A deployment mechanism like a deploy.sh scripy should handle deploying the application to the production environment. This step can be customized depending on the infrastructure (e.g., AWS, Azure, on-premises).

6. Monitoring and Notifications
Set up notifications to alert the development team about the status of the pipeline (successful builds, failures, etc.).

7. Continuous Deployment
For continuous deployment, we can extend the pipeline to automatically deploy the application to production after passing tests. It can have a manual approval step for critical environments.
